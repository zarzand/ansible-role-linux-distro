---

- name: network | Check NetworkManager service state
  ansible.builtin.service:
    name: NetworkManager.service
    state: started
  register: network_manager_status
  when: ansible_facts['services']['NetworkManager.service']['status'] | default('not-found') != 'not-found'

- name: network | Set fact if NetworkManager is active
  ansible.builtin.set_fact:
    network_manager_active: "{{ (ansible_facts['services']['NetworkManager.service']['status'] | default('not-found') != 'not-found' | default('true') | default('false'))  }}"

# -------------------------------------------- #
- name: network | Check networkd service state
  ansible.builtin.service:
    name: systemd-networkd.service
    state: started
  register: networkd_status
  when: ansible_facts['services']['systemd-networkd.service']['status'] | default('not-found') != 'not-found'

- name: network | Set fact if networkd is active
  ansible.builtin.set_fact:
    networkd_active: "{{ (ansible_facts['services']['systemd-networkd.service']['status'] | default('not-found') != 'not-found' | default('true') | default('false')) }}"

# -------------------------------------------- #
- name: network | Check for netplan configuration files
  ansible.builtin.find:
    paths: /etc/netplan
    patterns: "*.yaml"
  register: netplan_files

- name: network | Read netplan configuration if files exist
  ansible.builtin.slurp:
    src: "{{ item.path }}"
  loop: "{{ netplan_files.files }}"
  register: netplan_content
  when: netplan_files.files | length > 0

- name: network | Set fact netplan renderer is unknown when files not found
  ansible.builtin.set_fact:
    netplan_renderer: "unknown"
  when: netplan_files.files | length == 0
  no_log: true

- name: network | Read netplan content results
  ansible.builtin.set_fact:
    netplan_content_results: "{{ item.content | b64decode | from_yaml }}"
  loop: "{{ netplan_content.results }}"
  when: netplan_files.files | length > 0 and item.content is defined
  no_log: true

- name: network | Determine netplan renderer from content
  ansible.builtin.set_fact:
    netplan_renderer: "{{ netplan_content_results.network.renderer | default('none') }}"
  when: netplan_files.files | length > 0

- name: network | Determine primary network manager
  ansible.builtin.set_fact:
    primary_network_manager: >-
      {% if network_manager_active and netplan_renderer == 'NetworkManager' %}
         NetworkManagerViaNetplan
      {% elif network_manager_active %}
         NetworkManager
      {% elif (netplan_renderer == 'networkd' or netplan_renderer == 'none') %}
         SystemdNetworkdViaNetplan
      {% elif networkd_active and netplan_renderer == 'unknown' %}
        SystemdNetworkd
      {% else %}
        UnknownOrOtherMethod
      {% endif %}

- name: network | networkd_active
  ansible.builtin.debug:
    msg: "{{ primary_network_manager }}"

# -------------------------------------------- #
- name: network | Get ethernet interface name
  ansible.builtin.shell:
    cmd: |
      lshw -class network | awk '/description: Ethernet interface/{flag=1; next} /logical name:/ && flag{print $3; flag=0}'
  register: ethernet_interface_name

- name: network | Display ethernet interface name
  ansible.builtin.debug:
    msg: "{{ item }}"
  with_items: "{{ ethernet_interface_name.stdout_lines }}"

# -------------------------------------------- #